# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ig7Ie6eoecoKRBdbgvuAohnRmZTWBg_0
"""

import pandas as pd
import numpy as np

# --- 1. Load and Prepare Data ---
# Suppose your dataframe is named 'df' and has columns: ['date', 'hrc_mum']
df = pd.read_excel('weekly_hrc_new.xlsx')
df['date'] = pd.to_datetime(df['date'])
df = df.sort_values('date').reset_index(drop=True)

# Clean up column names by removing leading/trailing spaces
df.columns = df.columns.str.strip()

# Set 'date' as index for time-series ops (optional)
df.set_index('date', inplace=True)

# --- 2. Calculate Weekly Returns ---
# log returns: ln(Pt / Pt-1)
df['log_return'] = np.log(df['hrc_mum'] / df['hrc_mum'].shift(1))

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
plt.plot(df.index, df['log_return'])
plt.title('Weekly Log Returns of hrc_mum')
plt.xlabel('Date')
plt.ylabel('Log Return')
plt.grid(True)
plt.show()

df['cum_4w_return'] = df['log_return'].rolling(window=4).sum()

df['vol_4w'] = df['log_return'].rolling(window=4).std()

df['vol_12w'] = df['log_return'].rolling(window=12).std()

# Threshold: half of latest 12-week stddev (volatility), aligned per week
df['stable_threshold'] = 0.5 * df['vol_12w']

# Create a boolean: stable = abs(log_return) < threshold
df['is_stable'] = (df['log_return'].abs() < df['stable_threshold']).astype(int)

# Rolling count of stable weeks in each 4-week window
df['stable_count_4w'] = df['is_stable'].rolling(window=4).sum()  # 0 to 4

feature_df = df.dropna(subset=['cum_4w_return', 'vol_4w', 'vol_12w', 'stable_count_4w']).copy()

# Optionally, reset index and keep only features + current price as target
feature_df = feature_df.reset_index()
features = ['date', 'hrc_mum', 'cum_4w_return', 'vol_4w', 'vol_12w', 'stable_count_4w']
feature_df = feature_df[features]

feature_df['target_next_week'] = feature_df['hrc_mum'].shift(-1)

# List of features to use (X) and the supervised label (y)
final_features = ['cum_4w_return', 'vol_4w', 'vol_12w', 'stable_count_4w']
target = 'target_next_week'

df_model = feature_df.dropna(subset=final_features + [target]).copy()

# Example: use 80% for training, 20% for testing
n = len(df_model)
train_df = df_model.iloc[:int(0.8 * n)]
test_df  = df_model.iloc[int(0.8 * n):]

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_train = scaler.fit_transform(train_df[final_features])
X_test  = scaler.transform(test_df[final_features])

y_train = train_df[target].values
y_test  = test_df[target].values

print(df_model.head())